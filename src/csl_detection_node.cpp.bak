#include <ros/ros.h>
#include <cstdlib>
#include <iostream>
#include <math.h>
#include <stdio.h>
//#include <sensor_msgs/PointCloud2.h>   
#include <pcl_ros/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl_conversions/pcl_conversions.h>       
#include <pcl/visualization/cloud_viewer.h>
#include <boost/foreach.hpp>

using namespace std;
typedef pcl::PointCloud<pcl::PointXYZRGB> PointCloud;

//pcl::PointCloud<pcl::PointXYZRGB> cloud; 
PointCloud cloud; 

void PointCloudCallback(const PointCloud::ConstPtr& msg)        
{                                                                                    
    //pcl::fromROSMsg(*msg, cloud);  
    //pcl_conversions::toPCL(*msg, cloud);
    cloud.width = msg->width;
    cloud.height = msg->height;
    cloud.is_dense = msg->is_dense;
    cloud.points.resize( cloud.width * cloud.height );
    for( int i = 0; i < msg->points.size(); i++ )
    {
        //cout << msg->width << endl;
        //cout << msg->height << endl;
        //cout << msg->points[i].x << endl;
        if( msg->points[i].x != msg->points[i].x )
        {
            cloud.points[i].x = cloud.points[i].y = cloud.points[i].z = 0.0;
        }
        else
        {
            cloud.points[i] = msg->points[i];
        }
        //cout << cloud.points[i] << endl;
    }
    BOOST_FOREACH (const pcl::PointXYZRGB& pt, cloud.points)
    printf ("\t(%f, %f, %f)\n", pt.x, pt.y, pt.z);
}   



int main (int argc, char **argv){

    ros::init (argc, argv, "csl_detection_node");
    ros::NodeHandle nh;
    ros::Rate loop_rate( 10.0 );
    ros::Subscriber sub = nh.subscribe<PointCloud>("/camera/depth_registered/points", 1, PointCloudCallback);
    
    /*
    pcl::PointCloud<pcl::PointXYZ> cloud;

    // Fill in the cloud data
    cloud.width    = 5;
    cloud.height   = 1;
    cloud.is_dense = false;
    cloud.points.resize (cloud.width * cloud.height);

    for (size_t i = 0; i < cloud.points.size (); ++i)
    {
      cloud.points[i].x = 1024 * rand () / (RAND_MAX + 1.0f);
      cloud.points[i].y = 1024 * rand () / (RAND_MAX + 1.0f);
      cloud.points[i].z = 1024 * rand () / (RAND_MAX + 1.0f);
    }
    
    pcl::PointCloud<pcl::PointXYZ>::Ptr point_cloud_ptr(&cloud);*/
    
    
    
    pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr point_cloud_ptr(&cloud);
    pcl::visualization::CloudViewer viewer ("Simple Cloud Viewer");
    viewer.showCloud (point_cloud_ptr); 
    
    while (!viewer.wasStopped()){
        
	cout << cloud.width << endl;
	ros::spinOnce();
	
	//boost::this_thread::sleep (boost::posix_time::microseconds (100000));
	loop_rate.sleep();
     }
 	
     return 0;
}







