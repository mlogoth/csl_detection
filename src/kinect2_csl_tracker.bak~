#include <ros/ros.h>
#include <cstdlib>
#include <chrono>
#include <iostream>
#include <math.h>
#include <stdio.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/io/openni_grabber.h>
#include <pcl/console/parse.h>
#include <pcl/common/time.h>
#include <pcl/common/centroid.h>

#include <pcl/visualization/cloud_viewer.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/io/pcd_io.h>
#include <pcl/io/ply_io.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/approximate_voxel_grid.h>

#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>

#include <pcl/search/pcl_search.h>
#include <pcl/common/transforms.h>

#include <boost/format.hpp>

#include <pcl/tracking/tracking.h>
#include <pcl/tracking/particle_filter.h>
#include <pcl/tracking/kld_adaptive_particle_filter_omp.h>
#include <pcl/tracking/particle_filter_omp.h>
#include <pcl/tracking/coherence.h>
#include <pcl/tracking/distance_coherence.h>
#include <pcl/tracking/hsv_color_coherence.h>
#include <pcl/tracking/approx_nearest_pair_point_cloud_coherence.h>
#include <pcl/tracking/nearest_pair_point_cloud_coherence.h>

#define WITH_PCL
#include <csl_detection/k2g.h>

using namespace std;

string pcd_file_path = "/home/michalis/Downloads/coke.ply";

using namespace pcl::tracking;

typedef pcl::PointXYZRGB PointType;
typedef pcl::PointXYZRGBA RefPointType;
typedef ParticleXYZRPY ParticleT;

typedef pcl::PointCloud<pcl::PointXYZRGBA> Cloud;
typedef Cloud::Ptr CloudPtr;
typedef Cloud::ConstPtr CloudConstPtr;
typedef ParticleFilterTracker<RefPointType, ParticleT> ParticleFilter;

CloudPtr cloud_pass_;
CloudPtr cloud_pass_downsampled_;
// Target Cloud Variable
CloudPtr target_cloud;

boost::mutex mtx_;
boost::shared_ptr<ParticleFilter> tracker_;
bool new_cloud_;
double downsampling_grid_size_;
int counter;


//Filter along a specified dimension
void filterPassThrough (const CloudConstPtr &cloud, Cloud &result)
{
  pcl::PassThrough<pcl::PointXYZRGBA> pass;
  pass.setFilterFieldName ("z");
  pass.setFilterLimits (0.0, 10.0);
  pass.setKeepOrganized (false);
  pass.setInputCloud (cloud);
  pass.filter (result);
}


void gridSampleApprox (const CloudConstPtr &cloud, Cloud &result, double leaf_size)
{
  pcl::ApproximateVoxelGrid<pcl::PointXYZRGBA> grid;
  grid.setLeafSize (static_cast<float> (leaf_size), static_cast<float> (leaf_size), static_cast<float> (leaf_size));
  grid.setInputCloud (cloud);
  grid.filter (result);
}

//Draw the current particles
bool
drawParticles (pcl::visualization::PCLVisualizer& viz)
{
  ParticleFilter::PointCloudStatePtr particles = tracker_->getParticles ();
  if (particles && new_cloud_)
    {
      //Set pointCloud with particle's points
      pcl::PointCloud<pcl::PointXYZ>::Ptr particle_cloud (new pcl::PointCloud<pcl::PointXYZ> ());
      for (size_t i = 0; i < particles->points.size (); i++)
	{
	  pcl::PointXYZ point;
          
	  point.x = particles->points[i].x;
	  point.y = particles->points[i].y;
	  point.z = particles->points[i].z;
	  particle_cloud->points.push_back (point);
	}

      //Draw red particles 
      {
	pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> red_color (particle_cloud, 250, 99, 71);

	if (!viz.updatePointCloud (particle_cloud, red_color, "particle cloud"))
	  viz.addPointCloud (particle_cloud, red_color, "particle cloud");
      }
      return true;
    }
  else
    {
      return false;
    }
}

//Draw model reference point cloud
void
drawResult (pcl::visualization::PCLVisualizer& viz)
{
  ParticleXYZRPY result = tracker_->getResult ();
  Eigen::Affine3f transformation = tracker_->toEigenMatrix (result);

  //move close to camera a little for better visualization
  transformation.translation () += Eigen::Vector3f (0.0f, 0.0f, -0.005f);
  CloudPtr result_cloud (new Cloud ());
  pcl::transformPointCloud<RefPointType> (*(tracker_->getReferenceCloud ()), *result_cloud, transformation);

  //Draw blue model reference point cloud
  {
    pcl::visualization::PointCloudColorHandlerCustom<RefPointType> blue_color (result_cloud, 0, 0, 255);

    if (!viz.updatePointCloud (result_cloud, blue_color, "resultcloud"))
      viz.addPointCloud (result_cloud, blue_color, "resultcloud");
  }
}

//visualization's callback function
void
viz_cb (pcl::visualization::PCLVisualizer& viz)
{
  //boost::mutex::scoped_lock lock (mtx_);
    
  if (!cloud_pass_)
    {
      boost::this_thread::sleep (boost::posix_time::seconds (1));
      return;
   }

  //Draw downsampled point cloud from sensor    
  if (new_cloud_ && cloud_pass_downsampled_)
    {
      CloudPtr cloud_pass;
      cloud_pass = cloud_pass_downsampled_;
    
      if (!viz.updatePointCloud (cloud_pass, "cloudpass"))
	{
	  viz.addPointCloud (cloud_pass, "cloudpass");
	  viz.resetCameraViewpoint ("cloudpass");
	}
      bool ret = drawParticles (viz);
      if (ret)
        drawResult (viz);
    }
  new_cloud_ = false;
}

//OpenNI Grabber's cloud Callback function
void
cloud_cb (const CloudConstPtr &cloud)
{
  //boost::mutex::scoped_lock lock (mtx_);
  cloud_pass_.reset (new Cloud);
  cloud_pass_downsampled_.reset (new Cloud);
  filterPassThrough (cloud, *cloud_pass_);
  gridSampleApprox (cloud_pass_, *cloud_pass_downsampled_, downsampling_grid_size_);

  if(counter < 10){
	counter++;
  }else{
  	//Track the object
	tracker_->setInputCloud (cloud_pass_downsampled_);
	tracker_->compute ();
	new_cloud_ = true;
  }
}

int main (int argc, char **argv){

    ros::init (argc, argv, "kinect2_tracking_node");
    ros::NodeHandle nh;
    ros::Rate loop_rate(30);
    
    // TODO: Remove ()
    pcl::PointCloud<PointType>::Ptr scene (new pcl::PointCloud<PointType> ());
    pcl::PointCloud<pcl::PointXYZRGBA>::Ptr sceneA (new pcl::PointCloud<pcl::PointXYZRGBA> ());
    
    // Read Cloud RGB Type
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr read_cloud (new pcl::PointCloud<pcl::PointXYZRGB>()); 
    
    //read pcd file
    target_cloud.reset(new Cloud());
    if(pcl::io::loadPLYFile (pcd_file_path, *read_cloud) == -1){
      std::cout << "pcl file not found" << std::endl;
      exit(-1);
    }
    
    // Conver Target Point Cloud RGB to RGBA
    pcl::copyPointCloud(*read_cloud, *target_cloud);
    
    //Initialize Freenect Class
    processor freenectprocessor = CPU;
    K2G k2g(freenectprocessor);

    // Viewer
    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer(new pcl::visualization::PCLVisualizer ("3D Viewer"));
    
    viewer->setBackgroundColor (0, 0, 0);
    pcl::visualization::PointCloudColorHandlerRGBField<pcl::PointXYZRGB> rgb(scene);
    //pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZRGBA> target_rgb(target_cloud, 255,0,0);
    
    viewer->addPointCloud<pcl::PointXYZRGB>(scene, rgb, "sample cloud");
    //viewer->addPointCloud<pcl::PointXYZRGBA>(target_cloud, target_rgb, "target cloud");
    
    viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "sample cloud");
    //viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "target cloud");
    
    //Read Point Cloud using freenect2 Driver
    scene = k2g.getCloud();//Get once and set camera axes
    

    scene->sensor_orientation_.w() = 1.0;
    scene->sensor_orientation_.x() = 0.0;
    scene->sensor_orientation_.y() = 0.0;
    scene->sensor_orientation_.z() = 0.0;
    
    
    counter = 0;

    //Set parameters
    new_cloud_  = false;
    downsampling_grid_size_ =  0.002;

    std::vector<double> default_step_covariance = std::vector<double> (6, 0.015 * 0.015);
    default_step_covariance[3] *= 40.0;
    default_step_covariance[4] *= 40.0;
    default_step_covariance[5] *= 40.0;

    std::vector<double> initial_noise_covariance = std::vector<double> (6, 0.00001);
    std::vector<double> default_initial_mean = std::vector<double> (6, 0.0);

    boost::shared_ptr<KLDAdaptiveParticleFilterOMPTracker<RefPointType, ParticleT> > tracker
    (new KLDAdaptiveParticleFilterOMPTracker<RefPointType, ParticleT> (8));

    ParticleT bin_size;
    bin_size.x = 0.1f;
    bin_size.y = 0.1f;
    bin_size.z = 0.1f;
    bin_size.roll = 0.1f;
    bin_size.pitch = 0.1f;
    bin_size.yaw = 0.1f;
    
     //Set all parameters for  KLDAdaptiveParticleFilterOMPTracker
	tracker->setMaximumParticleNum (1000);
	tracker->setDelta (0.99);
	tracker->setEpsilon (0.2);
	tracker->setBinSize (bin_size);

	//Set all parameters for  ParticleFilter
	tracker_ = tracker;
	tracker_->setTrans (Eigen::Affine3f::Identity ());
	tracker_->setStepNoiseCovariance (default_step_covariance);
	tracker_->setInitialNoiseCovariance (initial_noise_covariance);
	tracker_->setInitialNoiseMean (default_initial_mean);
	tracker_->setIterationNum (1);
	tracker_->setParticleNum (600);
	tracker_->setResampleLikelihoodThr(0.00);
	tracker_->setUseNormal (false);
	cout<<" Hello 1"<<endl;
	//Setup coherence object for tracking
	ApproxNearestPairPointCloudCoherence<RefPointType>::Ptr coherence = ApproxNearestPairPointCloudCoherence<RefPointType>::Ptr
	(new ApproxNearestPairPointCloudCoherence<RefPointType> ());

	boost::shared_ptr<DistanceCoherence<RefPointType> > distance_coherence
	= boost::shared_ptr<DistanceCoherence<RefPointType> > (new DistanceCoherence<RefPointType> ());
	coherence->addPointCoherence (distance_coherence);

	boost::shared_ptr<pcl::search::Octree<RefPointType> > search (new pcl::search::Octree<RefPointType> (0.01));
	coherence->setSearchMethod (search);
	coherence->setMaximumDistance (0.01);
	cout<<" Hello 2"<<endl;
	tracker_->setCloudCoherence (coherence);
	cout<<" Hello 3"<<endl;
	//prepare the model of tracker's target
	Eigen::Vector4f c;
	Eigen::Affine3f trans = Eigen::Affine3f::Identity ();
	CloudPtr transed_ref (new Cloud);
	CloudPtr transed_ref_downsampled (new Cloud);


	pcl::compute3DCentroid<RefPointType> (*target_cloud, c);
	trans.translation ().matrix () = Eigen::Vector3f (c[0], c[1], c[2]);
	pcl::transformPointCloud<RefPointType> (*target_cloud, *transed_ref, trans.inverse());
	gridSampleApprox (transed_ref, *transed_ref_downsampled, downsampling_grid_size_);
	
	cout<<" Hello 4"<<endl;
	//set reference model and trans
	tracker_->setReferenceCloud (transed_ref_downsampled);

	cout<<" Hello 5"<<endl;
	tracker_->setTrans (trans);
	
	cout<<" Hello 6"<<endl;
	cloud_cb(sceneA);
	
	cout<<" Hello 7"<<endl;
	
	
    while (ros::ok()){

        viewer->spinOnce ();
        
		//Read Point Cloud using freenect2 Driver
    	scene = k2g.getCloud();
    	pcl::copyPointCloud(*scene, *sceneA);
    	cout<<" Hello 8"<<endl;
    	
    	cloud_cb(sceneA);
    	
    	cout<<" Hello 9"<<endl;
    	pcl::visualization::PointCloudColorHandlerRGBField<pcl::PointXYZRGBA> rgb(sceneA);
    	
    	viewer->updatePointCloud<pcl::PointXYZRGBA> (sceneA, rgb, "sample cloud");
    	//viewer->updatePointCloud<pcl::PointXYZRGBA>(target_cloud, target_rgb, "target cloud");
    	//ros::Duration(0.02).sleep();
    	ros::spinOnce();

    }
 	
 	
    k2g.shutDown();
  
    return 0;
}

